import { describe, it, expect, jest, beforeEach, afterEach } from '@jest/globals'

// Create mock functions first
const mockGetCurrentUserAction = jest.fn()
const mockDeleteAssistantArchitect = jest.fn().mockResolvedValue(true)
const mockHasToolAccess = jest.fn()
const mockExecuteSQL = jest.fn()
const mockLogError = jest.fn()

// Mock the dynamic imports properly
const mockLogger = {
  info: jest.fn(),
  debug: jest.fn(),
  warn: jest.fn(),
  error: mockLogError
}

// Mock dependencies 
jest.mock('@/lib/auth/server-session', () => ({
  getServerSession: jest.fn()
}))
jest.mock('@/actions/db/get-current-user-action', () => ({
  getCurrentUserAction: mockGetCurrentUserAction
}))
jest.mock('@/lib/db/data-api-adapter', () => ({
  executeSQL: mockExecuteSQL,
  deleteAssistantArchitect: mockDeleteAssistantArchitect,
  hasToolAccess: mockHasToolAccess
}))
jest.mock('@/lib/logger', () => ({
  createLogger: () => mockLogger,
  generateRequestId: () => 'test-request-id',
  startTimer: () => jest.fn()
}))

// Import after mocking
import { deleteAssistantArchitectAction } from '@/actions/db/assistant-architect-actions'
import { getServerSession } from '@/lib/auth/server-session'
import { executeSQL, hasToolAccess, deleteAssistantArchitect } from '@/lib/db/data-api-adapter'

describe('deleteAssistantArchitectAction - Ownership Validation', () => {
  const mockedGetServerSession = getServerSession as jest.Mock

  beforeEach(() => {
    jest.clearAllMocks()
    
    // Clear the log error mock
    mockLogError.mockClear()
    
    // Set up default mocks that should work for most tests
    mockDeleteAssistantArchitect.mockResolvedValue(true)
    mockHasToolAccess.mockResolvedValue(false) // Default: no admin access
    mockGetCurrentUserAction.mockResolvedValue({
      isSuccess: true,
      message: 'Success',
      data: {
        user: { id: 1, email: 'test@example.com' }
      }
    })
    
    // Mock the data type conversion that uses BigInt
    Object.defineProperty(BigInt.prototype, 'valueOf', {
      value: function() { return Number(this) },
      writable: true
    })
    
    // Mock the dynamic imports that happen in the function
    jest.doMock('@/actions/db/get-current-user-action', () => ({
      getCurrentUserAction: mockGetCurrentUserAction
    }))
    
    jest.doMock('@/lib/db/data-api-adapter', () => ({
      executeSQL: mockExecuteSQL,
      deleteAssistantArchitect: mockDeleteAssistantArchitect,
      hasToolAccess: mockHasToolAccess
    }))
  })

  afterEach(() => {
    jest.restoreAllMocks()
  })

  describe('Owner Deletion', () => {
    it('should allow owner to delete their own draft assistant', async () => {
      // Setup mocks
      mockedGetServerSession.mockResolvedValue({
        sub: 'user-123',
        email: 'owner@test.com',
        givenName: 'Test',
        familyName: 'User'
      })

      // Mock the sequence of SQL calls:
      // 1. First call gets the assistant details - user_id should match currentUser.id
      mockExecuteSQL
        .mockResolvedValueOnce([{ user_id: 1, status: 'draft' }])
        // 2. Second call deletes from tools table
        .mockResolvedValueOnce([])
        // 3. Third call deletes from navigation_items
        .mockResolvedValueOnce([])
        
      // Mock the dynamic import for deleteAssistantArchitect
      mockDeleteAssistantArchitect.mockResolvedValue(true)

      mockGetCurrentUserAction.mockResolvedValue({
        isSuccess: true,
        message: 'Success',
        data: {
          user: { id: 1, email: 'owner@test.com', cognitoSub: 'user-123' } as any,
          roles: []
        }
      })

      mockHasToolAccess.mockResolvedValue(false) // Not an admin (neither user-management nor role-management)

      // Execute
      const result = await deleteAssistantArchitectAction('1')

      // Debug: Log the actual result and any error that was logged
      console.log('Actual result:', JSON.stringify(result, null, 2))
      console.log('executeSQL calls:', mockExecuteSQL.mock.calls)
      console.log('getCurrentUserAction calls:', mockGetCurrentUserAction.mock.calls) 
      console.log('hasToolAccess calls:', mockHasToolAccess.mock.calls)
      if (mockLogError.mock.calls.length > 0) {
        console.log('Error logged:', mockLogError.mock.calls[0])
      }
      console.log('getServerSession calls:', mockedGetServerSession.mock.calls)

      // Assert
      expect(result.isSuccess).toBe(true)
      expect(result.message).toBe('Assistant architect deleted successfully')
    })

    it('should allow owner to delete their own rejected assistant', async () => {
      // Setup mocks
      mockedGetServerSession.mockResolvedValue({
        sub: 'user-123',
        email: 'owner@test.com',
        givenName: 'Test',
        familyName: 'User'
      })

      mockExecuteSQL
        .mockResolvedValueOnce([{ user_id: 1, status: 'rejected' }])
        .mockResolvedValueOnce([])
        .mockResolvedValueOnce([])
        
      mockDeleteAssistantArchitect.mockResolvedValue(true)

      mockGetCurrentUserAction.mockResolvedValue({
        isSuccess: true,
        message: 'Success',
        data: {
          user: { id: 1, email: 'owner@test.com', cognitoSub: 'user-123' } as any,
          roles: []
        }
      })

      mockHasToolAccess.mockResolvedValue(false) // Not an admin (neither user-management nor role-management)

      // Execute
      const result = await deleteAssistantArchitectAction('1')

      // Assert
      expect(result.isSuccess).toBe(true)
      expect(result.message).toBe('Assistant architect deleted successfully')
    })

    it('should prevent owner from deleting their own approved assistant', async () => {
      // Setup mocks
      mockedGetServerSession.mockResolvedValue({
        sub: 'user-123',
        email: 'owner@test.com',
        givenName: 'Test',
        familyName: 'User'
      })

      mockExecuteSQL.mockResolvedValue([{ user_id: 1, status: 'approved' }])

      mockGetCurrentUserAction.mockResolvedValue({
        isSuccess: true,
        message: 'Success',
        data: {
          user: { id: 1, email: 'owner@test.com', cognitoSub: 'user-123' } as any,
          roles: []
        }
      })

      // Execute
      const result = await deleteAssistantArchitectAction('1')

      // Assert
      expect(result.isSuccess).toBe(false)
      expect(result.message).toBe('Only draft or rejected assistants can be deleted')
    })
  })

  describe('Cross-User Protection', () => {
    it('should prevent non-owner non-admin from deleting another user\'s assistant', async () => {
      // Setup mocks
      mockedGetServerSession.mockResolvedValue({
        sub: 'user-456',
        email: 'other@test.com',
        givenName: 'Other',
        familyName: 'User'
      })

      mockExecuteSQL.mockResolvedValue([{ user_id: 1, status: 'draft' }]) // Owner is user ID 1

      mockGetCurrentUserAction.mockResolvedValue({
        isSuccess: true,
        message: 'Success',
        data: {
          user: { id: 2, email: 'other@test.com', cognitoSub: 'user-456' } as any, // Different user ID
          roles: []
        }
      })

      mockHasToolAccess.mockResolvedValue(false) // Not an admin (neither user-management nor role-management)

      // Execute
      const result = await deleteAssistantArchitectAction('1')

      // Assert
      expect(result.isSuccess).toBe(false)
      expect(result.message).toBe('You can only delete your own assistants')
    })
  })

  describe('Admin Override', () => {
    it('should allow admin to delete any draft assistant', async () => {
      // Setup mocks
      mockedGetServerSession.mockResolvedValue({
        sub: 'admin-789',
        email: 'admin@test.com',
        givenName: 'Admin',
        familyName: 'User'
      })

      mockExecuteSQL
        .mockResolvedValueOnce([{ user_id: 1, status: 'draft' }]) // Different owner
        .mockResolvedValueOnce([])
        .mockResolvedValueOnce([])
        
      mockDeleteAssistantArchitect.mockResolvedValue(true)

      mockGetCurrentUserAction.mockResolvedValue({
        isSuccess: true,
        message: 'Success',
        data: {
          user: { id: 3, email: 'admin@test.com', cognitoSub: 'admin-789' } as any, // Admin user
          roles: [{ id: 1, name: 'admin' }]
        }
      })

      // Mock both user-management and role-management checks for admin
      mockHasToolAccess.mockImplementation((async (sub: string, tool: string) => {
        return tool === 'user-management' || tool === 'role-management'
      }) as any)

      // Execute
      const result = await deleteAssistantArchitectAction('1')

      // Assert
      expect(result.isSuccess).toBe(true)
      expect(result.message).toBe('Assistant architect deleted successfully')
    })

    it('should prevent admin from deleting approved assistant', async () => {
      // Setup mocks
      mockedGetServerSession.mockResolvedValue({
        sub: 'admin-789',
        email: 'admin@test.com',
        givenName: 'Admin',
        familyName: 'User'
      })

      mockExecuteSQL.mockResolvedValue([{ user_id: 1, status: 'approved' }])

      mockGetCurrentUserAction.mockResolvedValue({
        isSuccess: true,
        message: 'Success',
        data: {
          user: { id: 3, email: 'admin@test.com', cognitoSub: 'admin-789' } as any,
          roles: [{ id: 1, name: 'admin' }]
        }
      })

      // Mock both user-management and role-management checks for admin
      mockHasToolAccess.mockImplementation((async (sub: string, tool: string) => {
        return tool === 'user-management' || tool === 'role-management'
      }) as any)

      // Execute
      const result = await deleteAssistantArchitectAction('1')

      // Assert
      expect(result.isSuccess).toBe(false)
      expect(result.message).toBe('Only draft or rejected assistants can be deleted')
    })
  })

  describe('Edge Cases', () => {
    it('should handle missing session gracefully', async () => {
      mockedGetServerSession.mockResolvedValue(null)

      const result = await deleteAssistantArchitectAction('1')

      expect(result.isSuccess).toBe(false)
      expect(result.message).toBe('Please sign in to delete assistants')
    })

    it('should handle invalid assistant ID', async () => {
      mockedGetServerSession.mockResolvedValue({
        sub: 'user-123',
        email: 'user@test.com',
        givenName: 'Test',
        familyName: 'User'
      })

      const result = await deleteAssistantArchitectAction('invalid-id')

      expect(result.isSuccess).toBe(false)
      expect(result.message).toBe('Invalid assistant ID')
    })

    it('should handle assistant not found', async () => {
      mockedGetServerSession.mockResolvedValue({
        sub: 'user-123',
        email: 'user@test.com',
        givenName: 'Test',
        familyName: 'User'
      })

      mockExecuteSQL.mockResolvedValue([]) // No assistant found
      
      // Mock getCurrentUserAction for the case when it's called
      mockGetCurrentUserAction.mockResolvedValue({
        isSuccess: true,
        message: 'Success',
        data: {
          user: { id: 1, email: 'user@test.com' }
        }
      })

      const result = await deleteAssistantArchitectAction('999')

      expect(result.isSuccess).toBe(false)
      expect(result.message).toBe('Assistant not found')
    })
  })
})