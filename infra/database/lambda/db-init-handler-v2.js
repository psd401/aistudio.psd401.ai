"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = handler;
const client_rds_data_1 = require("@aws-sdk/client-rds-data");
const rdsClient = new client_rds_data_1.RDSDataClient({});
// Migration files that should ALWAYS run (additive only)
const MIGRATION_FILES = [
    '010-knowledge-repositories.sql',
    '11_textract_jobs.sql',
    '12_textract_usage.sql'
    // Future migrations go here
];
// Initial setup files (only run on empty database)
const INITIAL_SETUP_FILES = [
    '001-enums.sql',
    '002-tables.sql',
    '003-constraints.sql',
    '004-indexes.sql',
    '005-initial-data.sql'
];
async function handler(event) {
    console.log('Database initialization event:', JSON.stringify(event, null, 2));
    if (event.RequestType === 'Delete') {
        return {
            PhysicalResourceId: event.PhysicalResourceId || 'db-init',
            Status: 'SUCCESS',
            Reason: 'Delete not required for database initialization'
        };
    }
    const { ClusterArn, SecretArn, DatabaseName } = event.ResourceProperties;
    try {
        // Check if this is a fresh database or existing one
        const isDatabaseEmpty = await checkIfDatabaseEmpty(ClusterArn, SecretArn, DatabaseName);
        if (isDatabaseEmpty) {
            console.log('Empty database detected - running full initialization');
            // Run initial setup files
            for (const sqlFile of INITIAL_SETUP_FILES) {
                console.log(`Executing initial setup: ${sqlFile}`);
                await executeFileStatements(ClusterArn, SecretArn, DatabaseName, sqlFile);
            }
        }
        else {
            console.log('Existing database detected - skipping initial setup files');
        }
        // ALWAYS run migrations (they should be idempotent)
        console.log('Running migrations...');
        // Ensure migration tracking table exists
        await ensureMigrationTable(ClusterArn, SecretArn, DatabaseName);
        // Run each migration that hasn't been run yet
        for (const migrationFile of MIGRATION_FILES) {
            const hasRun = await checkMigrationRun(ClusterArn, SecretArn, DatabaseName, migrationFile);
            if (!hasRun) {
                console.log(`Running migration: ${migrationFile}`);
                const startTime = Date.now();
                try {
                    await executeFileStatements(ClusterArn, SecretArn, DatabaseName, migrationFile);
                    // Record successful migration
                    await recordMigration(ClusterArn, SecretArn, DatabaseName, migrationFile, true, Date.now() - startTime);
                    console.log(`Migration ${migrationFile} completed successfully`);
                }
                catch (error) {
                    // Record failed migration
                    await recordMigration(ClusterArn, SecretArn, DatabaseName, migrationFile, false, Date.now() - startTime, error.message);
                    throw new Error(`Migration ${migrationFile} failed: ${error.message}`);
                }
            }
            else {
                console.log(`Skipping migration ${migrationFile} - already run`);
            }
        }
        return {
            PhysicalResourceId: 'db-init',
            Status: 'SUCCESS',
            Reason: 'Database initialization/migration completed successfully'
        };
    }
    catch (error) {
        console.error('Database operation failed:', error);
        return {
            PhysicalResourceId: 'db-init',
            Status: 'FAILED',
            Reason: `Database operation failed: ${error}`
        };
    }
}
async function checkIfDatabaseEmpty(clusterArn, secretArn, database) {
    try {
        // Check if users table exists (core table that should always exist)
        const result = await executeSql(clusterArn, secretArn, database, `SELECT COUNT(*) FROM information_schema.tables 
       WHERE table_schema = 'public' 
       AND table_name = 'users'`);
        const count = result.records?.[0]?.[0]?.longValue || 0;
        return count === 0;
    }
    catch (error) {
        // If we can't check, assume empty
        return true;
    }
}
async function ensureMigrationTable(clusterArn, secretArn, database) {
    // This exactly matches the existing migration_log structure
    const sql = `
    CREATE TABLE IF NOT EXISTS migration_log (
      id SERIAL PRIMARY KEY,
      step_number INTEGER NOT NULL,
      description TEXT NOT NULL,
      sql_executed TEXT,
      status VARCHAR(20) DEFAULT 'pending',
      error_message TEXT,
      executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
  `;
    await executeSql(clusterArn, secretArn, database, sql);
}
async function checkMigrationRun(clusterArn, secretArn, database, migrationFile) {
    try {
        const result = await executeSql(clusterArn, secretArn, database, `SELECT COUNT(*) FROM migration_log 
       WHERE description = '${migrationFile}' 
       AND status = 'completed'`);
        const count = result.records?.[0]?.[0]?.longValue || 0;
        return count > 0;
    }
    catch (error) {
        return false;
    }
}
async function recordMigration(clusterArn, secretArn, database, migrationFile, success, executionTime, errorMessage) {
    const maxStepResult = await executeSql(clusterArn, secretArn, database, `SELECT COALESCE(MAX(step_number), 0) + 1 as next_step FROM migration_log`);
    const nextStep = maxStepResult.records?.[0]?.[0]?.longValue || 1;
    const status = success ? 'completed' : 'failed';
    const errorPart = errorMessage ? `, error_message = '${errorMessage.replace(/'/g, "''")}'` : '';
    await executeSql(clusterArn, secretArn, database, `INSERT INTO migration_log (step_number, description, sql_executed, status${errorMessage ? ', error_message' : ''}) 
     VALUES (${nextStep}, '${migrationFile}', 'Migration file executed', '${status}'${errorMessage ? `, '${errorMessage.replace(/'/g, "''")}'` : ''})`);
}
async function executeFileStatements(clusterArn, secretArn, database, filename) {
    const sql = await getSqlContent(filename);
    const statements = splitSqlStatements(sql);
    for (const statement of statements) {
        if (statement.trim()) {
            await executeSql(clusterArn, secretArn, database, statement);
        }
    }
}
async function executeSql(clusterArn, secretArn, database, sql) {
    const command = new client_rds_data_1.ExecuteStatementCommand({
        resourceArn: clusterArn,
        secretArn: secretArn,
        database: database,
        sql: sql,
        includeResultMetadata: true
    });
    const response = await rdsClient.send(command);
    return response;
}
function splitSqlStatements(sql) {
    // Remove comments
    const withoutComments = sql
        .split('\n')
        .filter(line => !line.trim().startsWith('--'))
        .join('\n');
    // Split by semicolon but handle blocks
    const statements = [];
    let currentStatement = '';
    let inBlock = false;
    const lines = withoutComments.split('\n');
    for (const line of lines) {
        const trimmedLine = line.trim().toUpperCase();
        if (trimmedLine.startsWith('CREATE TYPE') ||
            trimmedLine.startsWith('CREATE FUNCTION') ||
            trimmedLine.startsWith('DROP TYPE')) {
            inBlock = true;
        }
        currentStatement += line + '\n';
        if (line.trim().endsWith(';')) {
            if (inBlock && (trimmedLine === ');' || trimmedLine.endsWith(');'))) {
                inBlock = false;
            }
            if (!inBlock) {
                statements.push(currentStatement.trim());
                currentStatement = '';
            }
        }
    }
    if (currentStatement.trim()) {
        statements.push(currentStatement.trim());
    }
    return statements;
}
async function getSqlContent(filename) {
    const fs = require('fs').promises;
    const path = require('path');
    try {
        const schemaPath = path.join(__dirname, 'schema', filename);
        const content = await fs.readFile(schemaPath, 'utf8');
        return content;
    }
    catch (error) {
        console.error(`Failed to read SQL file ${filename}:`, error);
        throw new Error(`Could not load SQL file: ${filename}`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGItaW5pdC1oYW5kbGVyLXYyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZGItaW5pdC1oYW5kbGVyLXYyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBZ0NBLDBCQTBFQztBQTFHRCw4REFBa0Y7QUFFbEYsTUFBTSxTQUFTLEdBQUcsSUFBSSwrQkFBYSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBYXhDLHlEQUF5RDtBQUN6RCxNQUFNLGVBQWUsR0FBRztJQUN0QixnQ0FBZ0M7SUFDaEMsc0JBQXNCO0lBQ3RCLHVCQUF1QjtJQUN2Qiw0QkFBNEI7Q0FDN0IsQ0FBQztBQUVGLG1EQUFtRDtBQUNuRCxNQUFNLG1CQUFtQixHQUFHO0lBQzFCLGVBQWU7SUFDZixnQkFBZ0I7SUFDaEIscUJBQXFCO0lBQ3JCLGlCQUFpQjtJQUNqQixzQkFBc0I7Q0FDdkIsQ0FBQztBQUVLLEtBQUssVUFBVSxPQUFPLENBQUMsS0FBMEI7SUFDdEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQ0FBZ0MsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUU5RSxJQUFJLEtBQUssQ0FBQyxXQUFXLEtBQUssUUFBUSxFQUFFLENBQUM7UUFDbkMsT0FBTztZQUNMLGtCQUFrQixFQUFFLEtBQUssQ0FBQyxrQkFBa0IsSUFBSSxTQUFTO1lBQ3pELE1BQU0sRUFBRSxTQUFTO1lBQ2pCLE1BQU0sRUFBRSxpREFBaUQ7U0FDMUQsQ0FBQztJQUNKLENBQUM7SUFFRCxNQUFNLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsR0FBRyxLQUFLLENBQUMsa0JBQWtCLENBQUM7SUFFekUsSUFBSSxDQUFDO1FBQ0gsb0RBQW9EO1FBQ3BELE1BQU0sZUFBZSxHQUFHLE1BQU0sb0JBQW9CLENBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUV4RixJQUFJLGVBQWUsRUFBRSxDQUFDO1lB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TSxFQUFFLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN0RCxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztRQUNmLE9BQU8sQ0FBQyxLQUFLLENBQUMsMkJBQTJCLFFBQVEsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzdELE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLFFBQVEsRUFBRSxDQUFDLENBQUM7SUFDMUQsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSRFNEYXRhQ2xpZW50LCBFeGVjdXRlU3RhdGVtZW50Q29tbWFuZCB9IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1yZHMtZGF0YSc7XG5cbmNvbnN0IHJkc0NsaWVudCA9IG5ldyBSRFNEYXRhQ2xpZW50KHt9KTtcblxuaW50ZXJmYWNlIEN1c3RvbVJlc291cmNlRXZlbnQge1xuICBSZXF1ZXN0VHlwZTogJ0NyZWF0ZScgfCAnVXBkYXRlJyB8ICdEZWxldGUnO1xuICBSZXNvdXJjZVByb3BlcnRpZXM6IHtcbiAgICBDbHVzdGVyQXJuOiBzdHJpbmc7XG4gICAgU2VjcmV0QXJuOiBzdHJpbmc7XG4gICAgRGF0YWJhc2VOYW1lOiBzdHJpbmc7XG4gICAgRW52aXJvbm1lbnQ6IHN0cmluZztcbiAgfTtcbiAgUGh5c2ljYWxSZXNvdXJjZUlkPzogc3RyaW5nO1xufVxuXG4vLyBNaWdyYXRpb24gZmlsZXMgdGhhdCBzaG91bGQgQUxXQVlTIHJ1biAoYWRkaXRpdmUgb25seSlcbmNvbnN0IE1JR1JBVElPTl9GSUxFUyA9IFtcbiAgJzAxMC1rbm93bGVkZ2UtcmVwb3NpdG9yaWVzLnNxbCcsXG4gICcxMV90ZXh0cmFjdF9qb2JzLnNxbCcsXG4gICcxMl90ZXh0cmFjdF91c2FnZS5zcWwnXG4gIC8vIEZ1dHVyZSBtaWdyYXRpb25zIGdvIGhlcmVcbl07XG5cbi8vIEluaXRpYWwgc2V0dXAgZmlsZXMgKG9ubHkgcnVuIG9uIGVtcHR5IGRhdGFiYXNlKVxuY29uc3QgSU5JVElBTF9TRVRVUF9GSUxFUyA9IFtcbiAgJzAwMS1lbnVtcy5zcWwnLFxuICAnMDAyLXRhYmxlcy5zcWwnLFxuICAnMDAzLWNvbnN0cmFpbnRzLnNxbCcsXG4gICcwMDQtaW5kZXhlcy5zcWwnLFxuICAnMDA1LWluaXRpYWwtZGF0YS5zcWwnXG5dO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihldmVudDogQ3VzdG9tUmVzb3VyY2VFdmVudCk6IFByb21pc2U8YW55PiB7XG4gIGNvbnNvbGUubG9nKCdEYXRhYmFzZSBpbml0aWFsaXphdGlvbiBldmVudDonLCBKU09OLnN0cmluZ2lmeShldmVudCwgbnVsbCwgMikpO1xuXG4gIGlmIChldmVudC5SZXF1ZXN0VHlwZSA9PT0gJ0RlbGV0ZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgUGh5c2ljYWxSZXNvdXJjZUlkOiBldmVudC5QaHlzaWNhbFJlc291cmNlSWQgfHwgJ2RiLWluaXQnLFxuICAgICAgU3RhdHVzOiAnU1VDQ0VTUycsXG4gICAgICBSZWFzb246ICdEZWxldGUgbm90IHJlcXVpcmVkIGZvciBkYXRhYmFzZSBpbml0aWFsaXphdGlvbidcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgeyBDbHVzdGVyQXJuLCBTZWNyZXRBcm4sIERhdGFiYXNlTmFtZSB9ID0gZXZlbnQuUmVzb3VyY2VQcm9wZXJ0aWVzO1xuXG4gIHRyeSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGZyZXNoIGRhdGFiYXNlIG9yIGV4aXN0aW5nIG9uZVxuICAgIGNvbnN0IGlzRGF0YWJhc2VFbXB0eSA9IGF3YWl0IGNoZWNrSWZEYXRhYmFzZUVtcHR5KENsdXN0ZXJBcm4sIFNlY3JldEFybiwgRGF0YWJhc2VOYW1lKTtcbiAgICBcbiAgICBpZiAoaXNEYXRhYmFzZUVtcHR5KSB7XG4gICAgICBjb25zb2xlLmxvZygnRW1wdHkgZGF0YWJhc2UgZGV0ZWN0ZWQgLSBydW5uaW5nIGZ1bGwgaW5pdGlhbGl6YXRpb24nKTtcbiAgICAgIFxuICAgICAgLy8gUnVuIGluaXRpYWwgc2V0dXAgZmlsZXNcbiAgICAgIGZvciAoY29uc3Qgc3FsRmlsZSBvZiBJTklUSUFMX1NFVFVQX0ZJTEVTKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBFeGVjdXRpbmcgaW5pdGlhbCBzZXR1cDogJHtzcWxGaWxlfWApO1xuICAgICAgICBhd2FpdCBleGVjdXRlRmlsZVN0YXRlbWVudHMoQ2x1c3RlckFybiwgU2VjcmV0QXJuLCBEYXRhYmFzZU5hbWUsIHNxbEZpbGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnRXhpc3RpbmcgZGF0YWJhc2UgZGV0ZWN0ZWQgLSBza2lwcGluZyBpbml0aWFsIHNldHVwIGZpbGVzJyk7XG4gICAgfVxuXG4gICAgLy8gQUxXQVlTIHJ1biBtaWdyYXRpb25zICh0aGV5IHNob3VsZCBiZSBpZGVtcG90ZW50KVxuICAgIGNvbnNvbGUubG9nKCdSdW5uaW5nIG1pZ3JhdGlvbnMuLi4nKTtcbiAgICBcbiAgICAvLyBFbnN1cmUgbWlncmF0aW9uIHRyYWNraW5nIHRhYmxlIGV4aXN0c1xuICAgIGF3YWl0IGVuc3VyZU1pZ3JhdGlvblRhYmxlKENsdXN0ZXJBcm4sIFNlY3JldEFybiwgRGF0YWJhc2VOYW1lKTtcbiAgICBcbiAgICAvLyBSdW4gZWFjaCBtaWdyYXRpb24gdGhhdCBoYXNuJ3QgYmVlbiBydW4geWV0XG4gICAgZm9yIChjb25zdCBtaWdyYXRpb25GaWxlIG9mIE1JR1JBVElPTl9GSUxFUykge1xuICAgICAgY29uc3QgaGFzUnVuID0gYXdhaXQgY2hlY2tNaWdyYXRpb25SdW4oQ2x1c3RlckFybiwgU2VjcmV0QXJuLCBEYXRhYmFzZU5hbWUsIG1pZ3JhdGlvbkZpbGUpO1xuICAgICAgXG4gICAgICBpZiAoIWhhc1J1bikge1xuICAgICAgICBjb25zb2xlLmxvZyhgUnVubmluZyBtaWdyYXRpb246ICR7bWlncmF0aW9uRmlsZX1gKTtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgZXhlY3V0ZUZpbGVTdGF0ZW1lbnRzKENsdXN0ZXJBcm4sIFNlY3JldEFybiwgRGF0YWJhc2VOYW1lLCBtaWdyYXRpb25GaWxlKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZWNvcmQgc3VjY2Vzc2Z1bCBtaWdyYXRpb25cbiAgICAgICAgICBhd2FpdCByZWNvcmRNaWdyYXRpb24oQ2x1c3RlckFybiwgU2VjcmV0QXJuLCBEYXRhYmFzZU5hbWUsIG1pZ3JhdGlvbkZpbGUsIHRydWUsIERhdGUubm93KCkgLSBzdGFydFRpbWUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBNaWdyYXRpb24gJHttaWdyYXRpb25GaWxlfSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAvLyBSZWNvcmQgZmFpbGVkIG1pZ3JhdGlvblxuICAgICAgICAgIGF3YWl0IHJlY29yZE1pZ3JhdGlvbihDbHVzdGVyQXJuLCBTZWNyZXRBcm4sIERhdGFiYXNlTmFtZSwgbWlncmF0aW9uRmlsZSwgZmFsc2UsIERhdGUubm93KCkgLSBzdGFydFRpbWUsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlncmF0aW9uICR7bWlncmF0aW9uRmlsZX0gZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBTa2lwcGluZyBtaWdyYXRpb24gJHttaWdyYXRpb25GaWxlfSAtIGFscmVhZHkgcnVuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIFBoeXNpY2FsUmVzb3VyY2VJZDogJ2RiLWluaXQnLFxuICAgICAgU3RhdHVzOiAnU1VDQ0VTUycsXG4gICAgICBSZWFzb246ICdEYXRhYmFzZSBpbml0aWFsaXphdGlvbi9taWdyYXRpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseSdcbiAgICB9O1xuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRGF0YWJhc2Ugb3BlcmF0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIFBoeXNpY2FsUmVzb3VyY2VJZDogJ2RiLWluaXQnLFxuICAgICAgU3RhdHVzOiAnRkFJTEVEJyxcbiAgICAgIFJlYXNvbjogYERhdGFiYXNlIG9wZXJhdGlvbiBmYWlsZWQ6ICR7ZXJyb3J9YFxuICAgIH07XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tJZkRhdGFiYXNlRW1wdHkoXG4gIGNsdXN0ZXJBcm46IHN0cmluZyxcbiAgc2VjcmV0QXJuOiBzdHJpbmcsXG4gIGRhdGFiYXNlOiBzdHJpbmdcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIC8vIENoZWNrIGlmIHVzZXJzIHRhYmxlIGV4aXN0cyAoY29yZSB0YWJsZSB0aGF0IHNob3VsZCBhbHdheXMgZXhpc3QpXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZVNxbChcbiAgICAgIGNsdXN0ZXJBcm4sXG4gICAgICBzZWNyZXRBcm4sXG4gICAgICBkYXRhYmFzZSxcbiAgICAgIGBTRUxFQ1QgQ09VTlQoKikgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIFxuICAgICAgIFdIRVJFIHRhYmxlX3NjaGVtYSA9ICdwdWJsaWMnIFxuICAgICAgIEFORCB0YWJsZV9uYW1lID0gJ3VzZXJzJ2BcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IGNvdW50ID0gcmVzdWx0LnJlY29yZHM/LlswXT8uWzBdPy5sb25nVmFsdWUgfHwgMDtcbiAgICByZXR1cm4gY291bnQgPT09IDA7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSWYgd2UgY2FuJ3QgY2hlY2ssIGFzc3VtZSBlbXB0eVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZU1pZ3JhdGlvblRhYmxlKFxuICBjbHVzdGVyQXJuOiBzdHJpbmcsXG4gIHNlY3JldEFybjogc3RyaW5nLFxuICBkYXRhYmFzZTogc3RyaW5nXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgLy8gVGhpcyBleGFjdGx5IG1hdGNoZXMgdGhlIGV4aXN0aW5nIG1pZ3JhdGlvbl9sb2cgc3RydWN0dXJlXG4gIGNvbnN0IHNxbCA9IGBcbiAgICBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyBtaWdyYXRpb25fbG9nIChcbiAgICAgIGlkIFNFUklBTCBQUklNQVJZIEtFWSxcbiAgICAgIHN0ZXBfbnVtYmVyIElOVEVHRVIgTk9UIE5VTEwsXG4gICAgICBkZXNjcmlwdGlvbiBURVhUIE5PVCBOVUxMLFxuICAgICAgc3FsX2V4ZWN1dGVkIFRFWFQsXG4gICAgICBzdGF0dXMgVkFSQ0hBUigyMCkgREVGQVVMVCAncGVuZGluZycsXG4gICAgICBlcnJvcl9tZXNzYWdlIFRFWFQsXG4gICAgICBleGVjdXRlZF9hdCBUSU1FU1RBTVAgREVGQVVMVCBDVVJSRU5UX1RJTUVTVEFNUFxuICAgIClcbiAgYDtcbiAgXG4gIGF3YWl0IGV4ZWN1dGVTcWwoY2x1c3RlckFybiwgc2VjcmV0QXJuLCBkYXRhYmFzZSwgc3FsKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tNaWdyYXRpb25SdW4oXG4gIGNsdXN0ZXJBcm46IHN0cmluZyxcbiAgc2VjcmV0QXJuOiBzdHJpbmcsXG4gIGRhdGFiYXNlOiBzdHJpbmcsXG4gIG1pZ3JhdGlvbkZpbGU6IHN0cmluZ1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZVNxbChcbiAgICAgIGNsdXN0ZXJBcm4sXG4gICAgICBzZWNyZXRBcm4sXG4gICAgICBkYXRhYmFzZSxcbiAgICAgIGBTRUxFQ1QgQ09VTlQoKikgRlJPTSBtaWdyYXRpb25fbG9nIFxuICAgICAgIFdIRVJFIGRlc2NyaXB0aW9uID0gJyR7bWlncmF0aW9uRmlsZX0nIFxuICAgICAgIEFORCBzdGF0dXMgPSAnY29tcGxldGVkJ2BcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IGNvdW50ID0gcmVzdWx0LnJlY29yZHM/LlswXT8uWzBdPy5sb25nVmFsdWUgfHwgMDtcbiAgICByZXR1cm4gY291bnQgPiAwO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZWNvcmRNaWdyYXRpb24oXG4gIGNsdXN0ZXJBcm46IHN0cmluZyxcbiAgc2VjcmV0QXJuOiBzdHJpbmcsXG4gIGRhdGFiYXNlOiBzdHJpbmcsXG4gIG1pZ3JhdGlvbkZpbGU6IHN0cmluZyxcbiAgc3VjY2VzczogYm9vbGVhbixcbiAgZXhlY3V0aW9uVGltZTogbnVtYmVyLFxuICBlcnJvck1lc3NhZ2U/OiBzdHJpbmdcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBtYXhTdGVwUmVzdWx0ID0gYXdhaXQgZXhlY3V0ZVNxbChcbiAgICBjbHVzdGVyQXJuLFxuICAgIHNlY3JldEFybixcbiAgICBkYXRhYmFzZSxcbiAgICBgU0VMRUNUIENPQUxFU0NFKE1BWChzdGVwX251bWJlciksIDApICsgMSBhcyBuZXh0X3N0ZXAgRlJPTSBtaWdyYXRpb25fbG9nYFxuICApO1xuICBcbiAgY29uc3QgbmV4dFN0ZXAgPSBtYXhTdGVwUmVzdWx0LnJlY29yZHM/LlswXT8uWzBdPy5sb25nVmFsdWUgfHwgMTtcbiAgXG4gIGNvbnN0IHN0YXR1cyA9IHN1Y2Nlc3MgPyAnY29tcGxldGVkJyA6ICdmYWlsZWQnO1xuICBjb25zdCBlcnJvclBhcnQgPSBlcnJvck1lc3NhZ2UgPyBgLCBlcnJvcl9tZXNzYWdlID0gJyR7ZXJyb3JNZXNzYWdlLnJlcGxhY2UoLycvZywgXCInJ1wiKX0nYCA6ICcnO1xuICBcbiAgYXdhaXQgZXhlY3V0ZVNxbChcbiAgICBjbHVzdGVyQXJuLFxuICAgIHNlY3JldEFybixcbiAgICBkYXRhYmFzZSxcbiAgICBgSU5TRVJUIElOVE8gbWlncmF0aW9uX2xvZyAoc3RlcF9udW1iZXIsIGRlc2NyaXB0aW9uLCBzcWxfZXhlY3V0ZWQsIHN0YXR1cyR7ZXJyb3JNZXNzYWdlID8gJywgZXJyb3JfbWVzc2FnZScgOiAnJ30pIFxuICAgICBWQUxVRVMgKCR7bmV4dFN0ZXB9LCAnJHttaWdyYXRpb25GaWxlfScsICdNaWdyYXRpb24gZmlsZSBleGVjdXRlZCcsICcke3N0YXR1c30nJHtlcnJvck1lc3NhZ2UgPyBgLCAnJHtlcnJvck1lc3NhZ2UucmVwbGFjZSgvJy9nLCBcIicnXCIpfSdgIDogJyd9KWBcbiAgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUZpbGVTdGF0ZW1lbnRzKFxuICBjbHVzdGVyQXJuOiBzdHJpbmcsXG4gIHNlY3JldEFybjogc3RyaW5nLFxuICBkYXRhYmFzZTogc3RyaW5nLFxuICBmaWxlbmFtZTogc3RyaW5nXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3Qgc3FsID0gYXdhaXQgZ2V0U3FsQ29udGVudChmaWxlbmFtZSk7XG4gIGNvbnN0IHN0YXRlbWVudHMgPSBzcGxpdFNxbFN0YXRlbWVudHMoc3FsKTtcbiAgXG4gIGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIHN0YXRlbWVudHMpIHtcbiAgICBpZiAoc3RhdGVtZW50LnRyaW0oKSkge1xuICAgICAgYXdhaXQgZXhlY3V0ZVNxbChjbHVzdGVyQXJuLCBzZWNyZXRBcm4sIGRhdGFiYXNlLCBzdGF0ZW1lbnQpO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBleGVjdXRlU3FsKFxuICBjbHVzdGVyQXJuOiBzdHJpbmcsXG4gIHNlY3JldEFybjogc3RyaW5nLFxuICBkYXRhYmFzZTogc3RyaW5nLFxuICBzcWw6IHN0cmluZ1xuKTogUHJvbWlzZTxhbnk+IHtcbiAgY29uc3QgY29tbWFuZCA9IG5ldyBFeGVjdXRlU3RhdGVtZW50Q29tbWFuZCh7XG4gICAgcmVzb3VyY2VBcm46IGNsdXN0ZXJBcm4sXG4gICAgc2VjcmV0QXJuOiBzZWNyZXRBcm4sXG4gICAgZGF0YWJhc2U6IGRhdGFiYXNlLFxuICAgIHNxbDogc3FsLFxuICAgIGluY2x1ZGVSZXN1bHRNZXRhZGF0YTogdHJ1ZVxuICB9KTtcblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJkc0NsaWVudC5zZW5kKGNvbW1hbmQpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbmZ1bmN0aW9uIHNwbGl0U3FsU3RhdGVtZW50cyhzcWw6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgLy8gUmVtb3ZlIGNvbW1lbnRzXG4gIGNvbnN0IHdpdGhvdXRDb21tZW50cyA9IHNxbFxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAuZmlsdGVyKGxpbmUgPT4gIWxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoJy0tJykpXG4gICAgLmpvaW4oJ1xcbicpO1xuXG4gIC8vIFNwbGl0IGJ5IHNlbWljb2xvbiBidXQgaGFuZGxlIGJsb2Nrc1xuICBjb25zdCBzdGF0ZW1lbnRzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgY3VycmVudFN0YXRlbWVudCA9ICcnO1xuICBsZXQgaW5CbG9jayA9IGZhbHNlO1xuICBcbiAgY29uc3QgbGluZXMgPSB3aXRob3V0Q29tbWVudHMuc3BsaXQoJ1xcbicpO1xuICBcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3QgdHJpbW1lZExpbmUgPSBsaW5lLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuICAgIFxuICAgIGlmICh0cmltbWVkTGluZS5zdGFydHNXaXRoKCdDUkVBVEUgVFlQRScpIHx8IFxuICAgICAgICB0cmltbWVkTGluZS5zdGFydHNXaXRoKCdDUkVBVEUgRlVOQ1RJT04nKSB8fFxuICAgICAgICB0cmltbWVkTGluZS5zdGFydHNXaXRoKCdEUk9QIFRZUEUnKSkge1xuICAgICAgaW5CbG9jayA9IHRydWU7XG4gICAgfVxuICAgIFxuICAgIGN1cnJlbnRTdGF0ZW1lbnQgKz0gbGluZSArICdcXG4nO1xuICAgIFxuICAgIGlmIChsaW5lLnRyaW0oKS5lbmRzV2l0aCgnOycpKSB7XG4gICAgICBpZiAoaW5CbG9jayAmJiAodHJpbW1lZExpbmUgPT09ICcpOycgfHwgdHJpbW1lZExpbmUuZW5kc1dpdGgoJyk7JykpKSB7XG4gICAgICAgIGluQmxvY2sgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCFpbkJsb2NrKSB7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaChjdXJyZW50U3RhdGVtZW50LnRyaW0oKSk7XG4gICAgICAgIGN1cnJlbnRTdGF0ZW1lbnQgPSAnJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIGlmIChjdXJyZW50U3RhdGVtZW50LnRyaW0oKSkge1xuICAgIHN0YXRlbWVudHMucHVzaChjdXJyZW50U3RhdGVtZW50LnRyaW0oKSk7XG4gIH1cbiAgXG4gIHJldHVybiBzdGF0ZW1lbnRzO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRTcWxDb250ZW50KGZpbGVuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJykucHJvbWlzZXM7XG4gIGNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IHNjaGVtYVBhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnc2NoZW1hJywgZmlsZW5hbWUpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBmcy5yZWFkRmlsZShzY2hlbWFQYXRoLCAndXRmOCcpO1xuICAgIHJldHVybiBjb250ZW50O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byByZWFkIFNRTCBmaWxlICR7ZmlsZW5hbWV9OmAsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBsb2FkIFNRTCBmaWxlOiAke2ZpbGVuYW1lfWApO1xuICB9XG59Il19